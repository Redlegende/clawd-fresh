import { NextRequest, NextResponse } from 'next/server';
import { google } from 'googleapis';
import { createClient } from '@supabase/supabase-js';

/**
 * ULTRA-DEBUG VERSION OF OAUTH CALLBACK
 * 
 * This version captures EVERYTHING and returns detailed diagnostics.
 * Use this when the standard callback isn't providing enough error info.
 * 
 * To use:
 * 1. Replace route.ts with this file
 * 2. Run OAuth flow
 * 3. Check Vercel logs for detailed diagnostics
 * 4. Fix the issue
 * 5. Replace with the standard route.ts.fixed
 */

// Capture all logs for debugging
const LOGS: { timestamp: string; type: string; message: string; data?: any }[] = [];

function log(type: string, message: string, data?: any) {
  const entry = {
    timestamp: new Date().toISOString(),
    type,
    message,
    data: data ? sanitizeData(data) : undefined
  };
  LOGS.push(entry);
  console.log(`[${type}] ${message}`, data ? JSON.stringify(data, null, 2) : '');
}

// Sanitize sensitive data for logging
function sanitizeData(data: any): any {
  if (typeof data !== 'object' || data === null) return data;
  
  const sanitized = { ...data };
  const sensitiveKeys = ['access_token', 'refresh_token', 'token', 'password', 'secret', 'key'];
  
  for (const key of Object.keys(sanitized)) {
    if (sensitiveKeys.some(sk => key.toLowerCase().includes(sk))) {
      sanitized[key] = sanitized[key] ? '[REDACTED]' : undefined;
    } else if (typeof sanitized[key] === 'object') {
      sanitized[key] = sanitizeData(sanitized[key]);
    }
  }
  
  return sanitized;
}

// Environment variable check
function checkEnvVars(): { valid: boolean; missing: string[]; present: string[] } {
  const required = [
    'NEXT_PUBLIC_SUPABASE_URL',
    'SUPABASE_SERVICE_KEY',
    'GOOGLE_CLIENT_ID',
    'GOOGLE_CLIENT_SECRET',
    'GOOGLE_REDIRECT_URI',
  ];
  
  const missing: string[] = [];
  const present: string[] = [];
  
  for (const key of required) {
    if (!process.env[key]) {
      missing.push(key);
    } else {
      present.push(key);
    }
  }
  
  return { valid: missing.length === 0, missing, present };
}

const oauth2Client = new google.auth.OAuth2(
  process.env.GOOGLE_CLIENT_ID,
  process.env.GOOGLE_CLIENT_SECRET,
  process.env.GOOGLE_REDIRECT_URI || 'http://localhost:3000/api/auth/callback/google'
);

// Create Supabase client with full diagnostics
function createSupabaseClient() {
  const url = process.env.NEXT_PUBLIC_SUPABASE_URL!;
  const key = process.env.SUPABASE_SERVICE_KEY!;
  
  log('CONFIG', 'Creating Supabase client', {
    url: url ? 'Set' : 'MISSING',
    key: key ? `Set (${key.length} chars)` : 'MISSING',
    schema: 'orchestrator'
  });
  
  return createClient(url, key, {
    db: {
      schema: 'orchestrator'
    },
    auth: {
      autoRefreshToken: false,
      persistSession: false
    }
  });
}

const supabase = createSupabaseClient();
const USER_ID = 'b4004bf7-9b69-47e5-8032-c0f39c654a61';

export async function GET(request: NextRequest) {
  log('REQUEST', 'OAuth callback received', {
    url: request.url,
    method: request.method,
    headers: Object.fromEntries(request.headers.entries())
  });
  
  // Step 0: Check environment variables
  const envCheck = checkEnvVars();
  log('ENV', 'Environment check', envCheck);
  
  if (!envCheck.valid) {
    const error = `Missing environment variables: ${envCheck.missing.join(', ')}`;
    log('ERROR', error);
    return createErrorResponse(request, 'env_missing', error);
  }
  
  try {
    const searchParams = request.nextUrl.searchParams;
    const code = searchParams.get('code');
    const error = searchParams.get('error');
    const state = searchParams.get('state');

    log('PARAMS', 'Query parameters received', { code: !!code, error, state });

    // Handle OAuth provider errors
    if (error) {
      log('ERROR', 'Google OAuth error parameter', { error });
      return createErrorResponse(request, 'oauth_provider_error', error);
    }

    if (!code) {
      log('ERROR', 'No authorization code received');
      return createErrorResponse(request, 'no_code', 'No authorization code received from Google');
    }

    // Step 1: Exchange code for tokens
    log('STEP', 'Step 1: Exchanging code for tokens');
    let tokens;
    try {
      log('GOOGLE', 'Calling oauth2Client.getToken');
      const tokenResponse = await oauth2Client.getToken(code);
      tokens = tokenResponse.tokens;
      log('GOOGLE', 'Token exchange successful', {
        hasAccessToken: !!tokens.access_token,
        hasRefreshToken: !!tokens.refresh_token,
        tokenType: tokens.token_type,
        expiryDate: tokens.expiry_date,
        scope: tokens.scope
      });
    } catch (tokenError: any) {
      log('ERROR', 'Token exchange failed', {
        message: tokenError.message,
        code: tokenError.code,
        response: tokenError.response?.data
      });
      return createErrorResponse(request, 'token_exchange', tokenError.message, tokenError);
    }

    oauth2Client.setCredentials(tokens);

    // Step 2: Get user info from Google
    log('STEP', 'Step 2: Getting user info from Google');
    let userInfo;
    try {
      const oauth2 = google.oauth2({ version: 'v2', auth: oauth2Client });
      const { data } = await oauth2.userinfo.get();
      userInfo = data;
      log('GOOGLE', 'User info retrieved', {
        id: userInfo.id,
        email: userInfo.email,
        name: userInfo.name,
        verified: userInfo.verified_email
      });
    } catch (userInfoError: any) {
      log('ERROR', 'Failed to get user info', {
        message: userInfoError.message,
        code: userInfoError.code
      });
      return createErrorResponse(request, 'user_info_fetch', userInfoError.message, userInfoError);
    }

    // Step 3: Get calendar list
    log('STEP', 'Step 3: Getting calendar list');
    let calendarList;
    try {
      const calendar = google.calendar({ version: 'v3', auth: oauth2Client });
      const { data } = await calendar.calendarList.list();
      calendarList = data;
      log('GOOGLE', 'Calendar list retrieved', {
        count: calendarList.items?.length,
        calendars: calendarList.items?.map((c: any) => ({ id: c.id, summary: c.summary, primary: c.primary }))
      });
    } catch (calendarError: any) {
      log('ERROR', 'Failed to get calendar list', {
        message: calendarError.message,
        code: calendarError.code
      });
      return createErrorResponse(request, 'calendar_list_fetch', calendarError.message, calendarError);
    }

    const primaryCal = calendarList.items?.find((c: any) => c.primary) || calendarList.items?.[0];
    
    if (!primaryCal) {
      log('ERROR', 'No calendars found');
      return createErrorResponse(request, 'no_calendars', 'No calendars found in Google account');
    }

    log('DATA', 'Primary calendar selected', {
      id: primaryCal.id,
      summary: primaryCal.summary,
      primary: primaryCal.primary
    });

    // Step 4: Database diagnostics
    log('STEP', 'Step 4: Running database diagnostics');
    
    // 4a: Check connection
    log('DB', 'Testing database connection...');
    const { data: connTest, error: connError } = await supabase
      .from('users')
      .select('count')
      .limit(1);
      
    if (connError) {
      log('ERROR', 'Database connection failed', {
        message: connError.message,
        code: connError.code,
        details: connError.details,
        hint: connError.hint
      });
      return createErrorResponse(request, 'db_connection', connError.message, connError);
    }
    log('DB', 'Database connection successful');

    // 4b: Verify user exists
    log('DB', `Checking if user ${USER_ID} exists...`);
    const { data: userExists, error: userCheckError } = await supabase
      .from('users')
      .select('id, email')
      .eq('id', USER_ID)
      .single();

    if (userCheckError) {
      log('ERROR', 'User check query failed', {
        message: userCheckError.message,
        code: userCheckError.code,
        details: userCheckError.details
      });
      return createErrorResponse(request, 'user_check_failed', userCheckError.message, userCheckError);
    }

    if (!userExists) {
      log('ERROR', 'User not found', { userId: USER_ID });
      return createErrorResponse(request, 'user_not_found', `User ${USER_ID} does not exist`);
    }
    log('DB', 'User verified', userExists);

    // 4c: Check existing calendar
    log('DB', 'Checking for existing calendar record...');
    const { data: existingCal, error: existingError } = await supabase
      .from('calendars')
      .select('*')
      .eq('user_id', USER_ID)
      .eq('provider', 'google')
      .eq('external_id', primaryCal.id)
      .maybeSingle();
      
    if (existingError) {
      log('WARN', 'Error checking existing calendar (continuing)', {
        message: existingError.message,
        code: existingError.code
      });
    } else if (existingCal) {
      log('DB', 'Found existing calendar record', { id: existingCal.id });
    } else {
      log('DB', 'No existing calendar record found (will insert)');
    }

    // Step 5: Prepare and validate data
    log('STEP', 'Step 5: Preparing calendar data for upsert');
    
    const calendarData = {
      user_id: USER_ID,
      provider: 'google',
      provider_account_id: userInfo.id,
      external_id: primaryCal?.id,
      name: primaryCal?.summary || 'Google Calendar',
      email: userInfo.email,
      color: primaryCal?.backgroundColor || '#4285F4',
      access_token: tokens.access_token,
      refresh_token: tokens.refresh_token,
      expires_at: tokens.expiry_date ? new Date(tokens.expiry_date).toISOString() : null,
      scopes: tokens.scope?.split(' ') || [],
      calendars: calendarList.items?.map((cal: any) => ({
        id: cal.id,
        summary: cal.summary,
        primary: cal.primary || false,
        selected: cal.selected || false,
      })),
      sync_enabled: true,
      is_active: true,
      updated_at: new Date().toISOString(),
    };

    // Validate required fields
    const requiredFields = ['user_id', 'provider', 'external_id', 'name'];
    const missingFields = requiredFields.filter(f => !calendarData[f as keyof typeof calendarData]);
    
    if (missingFields.length > 0) {
      log('ERROR', 'Missing required fields', { missingFields });
      return createErrorResponse(request, 'validation_error', `Missing fields: ${missingFields.join(', ')}`);
    }

    log('DATA', 'Calendar data prepared', calendarData);

    // Step 6: Execute upsert
    log('STEP', 'Step 6: Executing database upsert');
    log('DB', 'Upsert parameters', {
      table: 'calendars',
      onConflict: 'user_id,provider,external_id',
      dataKeys: Object.keys(calendarData)
    });
    
    const { data: upsertData, error: dbError } = await supabase
      .from('calendars')
      .upsert(calendarData, {
        onConflict: 'user_id,provider,external_id'
      })
      .select();

    if (dbError) {
      log('ERROR', 'Database upsert failed', {
        message: dbError.message,
        code: dbError.code,
        details: dbError.details,
        hint: dbError.hint
      });
      
      // Try to get more info about the error
      const errorDetails = {
        message: dbError.message,
        code: dbError.code,
        details: dbError.details,
        hint: dbError.hint,
        // Common error codes to check
        isRLSError: dbError.message?.toLowerCase().includes('row level security'),
        isConstraintError: dbError.message?.toLowerCase().includes('constraint'),
        isPermissionError: dbError.message?.toLowerCase().includes('permission'),
      };
      
      return createErrorResponse(request, 'db_upsert', dbError.message, errorDetails);
    }

    log('DB', 'Database upsert successful', upsertData);

    // Success!
    log('SUCCESS', 'OAuth callback completed successfully');
    
    // Return success with debug info (only in development)
    if (process.env.NODE_ENV === 'development') {
      return NextResponse.json({
        success: true,
        message: 'Calendar connected successfully',
        logs: LOGS,
        user: userInfo.email,
        calendar: primaryCal.summary
      });
    }
    
    return NextResponse.redirect(
      new URL('/settings?success=calendar_connected', request.url)
    );

  } catch (error: any) {
    log('ERROR', 'Unexpected error in OAuth callback', {
      message: error.message,
      stack: error.stack,
      name: error.name
    });
    
    return createErrorResponse(request, 'unexpected', error.message, {
      stack: error.stack,
      name: error.name
    });
  }
}

function createErrorResponse(
  request: NextRequest,
  errorCode: string,
  errorMessage: string,
  details?: any
) {
  // Log the full error context
  console.error('=== OAUTH ERROR ===');
  console.error('Error Code:', errorCode);
  console.error('Error Message:', errorMessage);
  console.error('Details:', JSON.stringify(details, null, 2));
  console.error('Full Logs:', JSON.stringify(LOGS, null, 2));
  console.error('===================');
  
  // In development, return JSON with full details
  if (process.env.NODE_ENV === 'development') {
    return NextResponse.json({
      success: false,
      error: errorCode,
      message: errorMessage,
      details,
      logs: LOGS
    }, { status: 500 });
  }
  
  // In production, redirect with error code
  const errorParams = new URLSearchParams();
  errorParams.set('error', errorCode);
  errorParams.set('details', errorMessage);
  
  return NextResponse.redirect(
    new URL(`/settings?${errorParams.toString()}`, request.url)
  );
}
